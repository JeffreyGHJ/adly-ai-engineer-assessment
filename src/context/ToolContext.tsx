import React, { createContext, useContext, useState } from 'react';
import { getRandomId } from '../lib/utils';

export type ToolType = 'humanizer' | 'plagiarism' | 'ai-detector';

export interface Document {
  id: string;
  title: string;
  content: string;
  processedContent?: string;
  toolType: ToolType;
  createdAt: Date;
  lastModified: Date;
}

interface ToolContextType {
  currentTool: ToolType;
  setCurrentTool: (tool: ToolType) => void;
  documents: Document[];
  currentDocument: Document | null;
  setCurrentDocument: (document: Document | null) => void;
  addDocument: (document: Partial<Document>) => Document;
  updateDocument: (id: string, updates: Partial<Document>) => void;
  deleteDocument: (id: string) => void;
  processText: (text: string, tool: ToolType) => Promise<string>;
}

const ToolContext = createContext<ToolContextType | undefined>(undefined);

export function ToolProvider({ children }: { children: React.ReactNode }) {
  const [currentTool, setCurrentTool] = useState<ToolType>('humanizer');
  const [documents, setDocuments] = useState<Document[]>([]);
  const [currentDocument, setCurrentDocument] = useState<Document | null>(null);
  
  const addDocument = (documentData: Partial<Document>): Document => {
    const newDocument: Document = {
      id: getRandomId(),
      title: documentData.title || 'Untitled Document',
      content: documentData.content || '',
      processedContent: documentData.processedContent,
      toolType: documentData.toolType || 'humanizer',
      createdAt: new Date(),
      lastModified: new Date(),
    };
    
    setDocuments(prev => [newDocument, ...prev]);
    return newDocument;
  };
  
  const updateDocument = (id: string, updates: Partial<Document>) => {
    setDocuments(prev => 
      prev.map(doc => 
        doc.id === id 
          ? { ...doc, ...updates, lastModified: new Date() } 
          : doc
      )
    );
    
    if (currentDocument?.id === id) {
      setCurrentDocument(prev => 
        prev ? { ...prev, ...updates, lastModified: new Date() } : null
      );
    }
  };
  
  const deleteDocument = (id: string) => {
    setDocuments(prev => prev.filter(doc => doc.id !== id));
    if (currentDocument?.id === id) {
      setCurrentDocument(null);
    }
  };
  
  // Mock text processing function - in a real app this would call an API
  const processText = async (text: string, tool: ToolType): Promise<string> => {
    // Simulate API call
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    switch (tool) {
      case 'humanizer':
        // Simulate humanizing the text
        return text
          .split('. ')
          .map((sentence, i) => {
            if (i % 2 === 0) return sentence + ', actually';
            if (i % 3 === 0) return 'I mean, ' + sentence.toLowerCase();
            return sentence;
          })
          .join('. ');
      
      case 'plagiarism':
        // Simulate plagiarism check
        return `Plagiarism analysis complete. This text appears to be ${
          Math.floor(Math.random() * 15)
        }% similar to existing content.`;
      
      case 'ai-detector':
        // Simulate AI detection
        const aiScore = Math.floor(Math.random() * 100);
        return `AI Probability Score: ${aiScore}%. ${
          aiScore > 70 
            ? 'This text was likely generated by AI.' 
            : 'This text was likely written by a human.'
        }`;
      
      default:
        return text;
    }
  };
  
  const value = {
    currentTool,
    setCurrentTool,
    documents,
    currentDocument,
    setCurrentDocument,
    addDocument,
    updateDocument,
    deleteDocument,
    processText,
  };
  
  return <ToolContext.Provider value={value}>{children}</ToolContext.Provider>;
}

export function useTool() {
  const context = useContext(ToolContext);
  if (context === undefined) {
    throw new Error('useTool must be used within a ToolProvider');
  }
  return context;
}